package tod.impl.bci.asm;

import java.util.ArrayList;
import java.util.List;

import org.objectweb.asm.Attribute;
import org.objectweb.asm.ByteVector;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;

import tod.core.database.structure.IBehaviorInfo.BytecodeTagType;
import tod.impl.database.structure.standard.TagMap;

/**
 * Represents a non-standard code attribute (based on those generated by soot).
 * The binary form is:
 * - one short to indicate the number of entries
 * - each entry is of the form (short pc, int v) where pc represents a 
 * bytecode index and v a value.
 * @author gpothier
 */
public class TaggingAttribute extends Attribute
{
	private TaggingAttribute.Entry[] itsEntries;
	
	public TaggingAttribute(String aType)
	{
		this(aType, null);
	}
	
	public TaggingAttribute(String aType, TaggingAttribute.Entry[] aEntries)
	{
		super(aType);
		itsEntries = aEntries;
	}
	
	/**
	 * Fills the given tagmap with information about this attribute's tags.
	 * @param aTagMap
	 */
	public void fillTagMap(TagMap aTagMap, int aCodeSize, Tagger aTagger)
	{
		for (BytecodeTagType theType : BytecodeTagType.ALL)
		{
			int theCurrentPc = 0;
			int theCurrentValue = -1;
			
			for (TaggingAttribute.Entry theEntry : itsEntries)
			{
				Object theTag = aTagger.getTag(theType, theCurrentValue);
				int theNextPc = theEntry.label.getOffset();
				if (theTag != null) aTagMap.putTagRange(
						theType, 
						theTag, 
						theCurrentPc,
						theNextPc);
				
				theCurrentPc = theNextPc;
				theCurrentValue = theEntry.v;
			}
			
			Object theTag = aTagger.getTag(theType, theCurrentValue);
			int theNextPc = aCodeSize;
			if (theTag != null) aTagMap.putTagRange(
					theType, 
					theTag, 
					theCurrentPc,
					theNextPc);
		}
	}
	
	@Override
	public boolean isCodeAttribute()
	{
		return true;
	}
	
	private Label getLabel(int offset, Label[] labels)
	{
		Label l = labels[offset];
		if (l != null) return l;
		return labels[offset] = new Label();
	}

	@Override
	protected Attribute read(
			ClassReader cr, 
			int off, 
			int len, 
			char[] buf, 
			int codeOff, 
			Label[] labels)
	{
        int theEntriesCount = cr.readUnsignedShort(off);
        TaggingAttribute.Entry[] theEntries = new TaggingAttribute.Entry[theEntriesCount];
        for(int i=0;i<theEntriesCount;i++)
        {
        	int thePc = cr.readUnsignedShort(off + 2 + i*6);
        	int theValue = cr.readInt(off + 2 + i*6 + 2);
        	theEntries[i] = new Entry(getLabel(thePc, labels), theValue);
        }
        
        return new TaggingAttribute(type, theEntries);
	}
	
	@Override
	protected ByteVector write(
			ClassWriter cw, 
			byte[] code, 
			int len, 
			int maxStack, 
			int maxLocals)
	{
		ByteVector bv = new ByteVector();
		bv.putShort(itsEntries.length);
		for (TaggingAttribute.Entry theEntry : itsEntries)
		{
			bv.putShort(theEntry.label.getOffset());
			bv.putInt(theEntry.v);
		}
		return bv;
	}
	
	@Override
	protected Label[] getLabels()
	{
		List<Label> labels = new ArrayList<Label>();
		for (TaggingAttribute.Entry theEntry : itsEntries) labels.add(theEntry.label);
		return (Label[]) labels.toArray(new Label[labels.size()]);
	}
	
	public static class Entry
	{
		public final Label label;
		public final int v;
		
		public Entry(Label aLabel, int aV)
		{
			label = aLabel;
			v = aV;
		}
	}
}