/*
TOD - Trace Oriented Debugger.
Copyright (C) 2006 Guillaume Pothier (gpothier@dcc.uchile.cl)

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
version 2 as published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

Parts of this work rely on the MD5 algorithm "derived from the 
RSA Data Security, Inc. MD5 Message-Digest Algorithm".
*/
package tod.impl.bci.asm;

import java.util.ArrayList;
import java.util.List;

import org.objectweb.asm.Attribute;
import org.objectweb.asm.ByteVector;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;

import tod.core.bci.IInstrumenter;
import tod.core.database.structure.IStructureDatabase;
import zz.utils.Utils;

/**
 * This class instruments classes of the application VM
 * so that they send logging information to the debugger VM
 * @author gpothier
 */
public class ASMInstrumenter implements IInstrumenter
{
	private final IStructureDatabase itsDatabase;
	private final ASMDebuggerConfig itsConfig;
	
	public ASMInstrumenter(IStructureDatabase aDatabase, ASMDebuggerConfig aConfig)
	{
		itsDatabase = aDatabase;
		itsConfig = aConfig;
	}
	
	public void setTraceWorkingSet(String aWorkingSet)
	{
		itsConfig.setTraceWorkingSet(aWorkingSet);
	}
	
	public void setGlobalWorkingSet(String aWorkingSet)
	{
		itsConfig.setGlobalWorkingSet(aWorkingSet);
	}
	


	public InstrumentedClass instrumentClass (String aName, byte[] aBytecode)
    {
		if (! BCIUtils.acceptClass(aName, itsConfig.getGlobalSelector())) return null;
		
		String theChecksum = Utils.md5String(aBytecode);
		
		ClassReader theReader = new ClassReader(aBytecode);
		ClassWriter theWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);
		
		// Pass 1: collect method info 
		InfoCollector theInfoCollector = new InfoCollector();
		theReader.accept(theInfoCollector, ClassReader.SKIP_DEBUG);
		
		List<Integer> theTracedMethods = new ArrayList<Integer>();
		
		// Pass 2: actual instrumentation
		LogBCIVisitor theVisitor = new LogBCIVisitor(
				itsDatabase,
				itsConfig, 
				theInfoCollector,
				theWriter,
				theChecksum,
				theTracedMethods);
		
		Attribute[] theAttributes = new Attribute[] {
				new SootAttribute("ca.mcgill.sable.InstructionKind"),
				new SootAttribute("ca.mcgill.sable.InstructionShadow"),
				new SootAttribute("ca.mcgill.sable.InstructionSource"),
		};
		
		theReader.accept(theVisitor, theAttributes, 0);
		
		return theVisitor.isModified()  
			? new InstrumentedClass(theWriter.toByteArray(), theTracedMethods) 
			: null;
    }

	/**
	 * Represents a non-standard code attribute generated by soot.
	 * The form is:
	 * - one short to indicate the number of entries
	 * - each entry is of the form (short pc, int v) where pc represents a 
	 * bytecode index and v a value.
	 * @author gpothier
	 */
	public static class SootAttribute extends Attribute
	{
		private Entry[] itsEntries;
		
		public SootAttribute(String aType)
		{
			this(aType, null);
		}
		
		public SootAttribute(String aType, Entry[] aEntries)
		{
			super(aType);
			itsEntries = aEntries;
		}
		
		@Override
		public boolean isCodeAttribute()
		{
			return true;
		}
		
		private Label getLabel(int offset, Label[] labels)
		{
			Label l = labels[offset];
			if (l != null) return l;
			return labels[offset] = new Label();
		}

		@Override
		protected Attribute read(
				ClassReader cr, 
				int off, 
				int len, 
				char[] buf, 
				int codeOff, 
				Label[] labels)
		{
	        int theEntriesCount = cr.readUnsignedShort(off);
	        Entry[] theEntries = new Entry[theEntriesCount];
	        for(int i=0;i<theEntriesCount;i++)
	        {
	        	int thePc = cr.readUnsignedShort(off + 2 + i*6);
	        	int theValue = cr.readInt(off + 2 + i*6 + 2);
	        	theEntries[i] = new Entry(getLabel(thePc, labels), theValue);
	        }
	        
	        return new SootAttribute(type, theEntries);
		}
		
		@Override
		protected ByteVector write(
				ClassWriter cw, 
				byte[] code, 
				int len, 
				int maxStack, 
				int maxLocals)
		{
			ByteVector bv = new ByteVector();
			bv.putShort(itsEntries.length);
			for (Entry theEntry : itsEntries)
			{
				bv.putShort(theEntry.label.getOffset());
				bv.putInt(theEntry.v);
			}
			return bv;
		}
		
		@Override
		protected Label[] getLabels()
		{
			List<Label> labels = new ArrayList<Label>();
			for (Entry theEntry : itsEntries) labels.add(theEntry.label);
			return (Label[]) labels.toArray(new Label[labels.size()]);
		}
		
		public static class Entry
		{
			public final Label label;
			public final int v;
			
			public Entry(Label aLabel, int aV)
			{
				label = aLabel;
				v = aV;
			}
		}
	}
}
