/*
TOD - Trace Oriented Debugger.
Copyright (C) 2006 Guillaume Pothier (gpothier@dcc.uchile.cl)

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
version 2 as published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

Parts of this work rely on the MD5 algorithm "derived from the 
RSA Data Security, Inc. MD5 Message-Digest Algorithm".
*/
package tod.impl.bci.asm;

import java.util.ArrayList;
import java.util.List;

import org.objectweb.asm.Attribute;
import org.objectweb.asm.ByteVector;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;

import tod.core.bci.IInstrumenter;
import tod.core.database.structure.IMutableStructureDatabase;
import tod.core.database.structure.IBehaviorInfo.BytecodeRole;
import tod.core.database.structure.IBehaviorInfo.BytecodeTagType;
import tod.impl.database.structure.standard.TagMap;
import zz.utils.Utils;

/**
 * This class instruments classes of the application VM
 * so that they send logging information to the debugger VM
 * @author gpothier
 */
public class ASMInstrumenter implements IInstrumenter
{
	public static final String ATTR_INSTRUCTION_SOURCE = "ca.mcgill.sable.InstructionSource";
	public static final String ATTR_INSTRUCTION_SHADOW = "ca.mcgill.sable.InstructionShadow";
	public static final String ATTR_INSTRUCTION_KIND = "ca.mcgill.sable.InstructionKind";
	private final IMutableStructureDatabase itsDatabase;
	private final ASMDebuggerConfig itsConfig;
	
	public ASMInstrumenter(IMutableStructureDatabase aDatabase, ASMDebuggerConfig aConfig)
	{
		itsDatabase = aDatabase;
		itsConfig = aConfig;
	}
	
	public void setTraceWorkingSet(String aWorkingSet)
	{
		itsConfig.setTraceWorkingSet(aWorkingSet);
	}
	
	public void setGlobalWorkingSet(String aWorkingSet)
	{
		itsConfig.setGlobalWorkingSet(aWorkingSet);
	}
	


	public InstrumentedClass instrumentClass (String aName, byte[] aBytecode)
    {
		if (! BCIUtils.acceptClass(aName, itsConfig.getGlobalSelector())) return null;
		
		String theChecksum = Utils.md5String(aBytecode);
		
		ClassReader theReader = new ClassReader(aBytecode);
		ClassWriter theWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);
		
		// Pass 1: collect method info 
		InfoCollector theInfoCollector = new InfoCollector();
		theReader.accept(theInfoCollector, ClassReader.SKIP_DEBUG);
		
		List<Integer> theTracedMethods = new ArrayList<Integer>();
		
		// Pass 2: actual instrumentation
		LogBCIVisitor theVisitor = new LogBCIVisitor(
				itsDatabase,
				itsConfig, 
				theInfoCollector,
				theWriter,
				theChecksum,
				theTracedMethods);
		
		Attribute[] theAttributes = new Attribute[] {
				new TaggingAttribute(ATTR_INSTRUCTION_KIND),
				new TaggingAttribute(ATTR_INSTRUCTION_SHADOW),
				new TaggingAttribute(ATTR_INSTRUCTION_SOURCE),
		};
		
		theReader.accept(theVisitor, theAttributes, 0);
		
		byte[] theBytecode = theWriter.toByteArray();
		
		theVisitor.getClassInfo().setBytecode(theBytecode);
		
		return theVisitor.isModified()  
			? new InstrumentedClass(theBytecode, theTracedMethods) 
			: null;
    }

	/**
	 * Represents a non-standard code attribute (based on those generated by soot).
	 * The binary form is:
	 * - one short to indicate the number of entries
	 * - each entry is of the form (short pc, int v) where pc represents a 
	 * bytecode index and v a value.
	 * @author gpothier
	 */
	public static class TaggingAttribute extends Attribute
	{
		private Entry[] itsEntries;
		
		public TaggingAttribute(String aType)
		{
			this(aType, null);
		}
		
		public TaggingAttribute(String aType, Entry[] aEntries)
		{
			super(aType);
			itsEntries = aEntries;
		}
		
		/**
		 * Fills the given tagmap with information about this attribute's tags.
		 * @param aTagMap
		 */
		public void fillTagMap(TagMap aTagMap, Tagger aTagger)
		{
			for (Entry theEntry : itsEntries)
			{
				for (BytecodeTagType theType : BytecodeTagType.ALL)
				{
					Object theTag = aTagger.getTag(theType, theEntry.v);
					if (theTag != null) aTagMap.putTag(theType, theTag, theEntry.label.getOffset());
				}
			}
		}
		
		@Override
		public boolean isCodeAttribute()
		{
			return true;
		}
		
		private Label getLabel(int offset, Label[] labels)
		{
			Label l = labels[offset];
			if (l != null) return l;
			return labels[offset] = new Label();
		}

		@Override
		protected Attribute read(
				ClassReader cr, 
				int off, 
				int len, 
				char[] buf, 
				int codeOff, 
				Label[] labels)
		{
	        int theEntriesCount = cr.readUnsignedShort(off);
	        Entry[] theEntries = new Entry[theEntriesCount];
	        for(int i=0;i<theEntriesCount;i++)
	        {
	        	int thePc = cr.readUnsignedShort(off + 2 + i*6);
	        	int theValue = cr.readInt(off + 2 + i*6 + 2);
	        	theEntries[i] = new Entry(getLabel(thePc, labels), theValue);
	        }
	        
	        return new TaggingAttribute(type, theEntries);
		}
		
		@Override
		protected ByteVector write(
				ClassWriter cw, 
				byte[] code, 
				int len, 
				int maxStack, 
				int maxLocals)
		{
			ByteVector bv = new ByteVector();
			bv.putShort(itsEntries.length);
			for (Entry theEntry : itsEntries)
			{
				bv.putShort(theEntry.label.getOffset());
				bv.putInt(theEntry.v);
			}
			return bv;
		}
		
		@Override
		protected Label[] getLabels()
		{
			List<Label> labels = new ArrayList<Label>();
			for (Entry theEntry : itsEntries) labels.add(theEntry.label);
			return (Label[]) labels.toArray(new Label[labels.size()]);
		}
		
		public static class Entry
		{
			public final Label label;
			public final int v;
			
			public Entry(Label aLabel, int aV)
			{
				label = aLabel;
				v = aV;
			}
		}
	}
	
	/**
	 * Implements the mechanism to transform soot attributes into tod tags.
	 * @author gpothier
	 */
	public static abstract class Tagger
	{
		public abstract <T> T getTag(BytecodeTagType<T> aType, int aValue);
		
	}

	/**
	 * Handles the instruction kind soot tag provided by the abc compiler.
	 * It indicates the role of each bytecode
	 * @author gpothier
	 */
	public static class SootInstructionKindTagger extends Tagger
	{
		private static SootInstructionKindTagger INSTANCE = new SootInstructionKindTagger();

		public static SootInstructionKindTagger getInstance()
		{
			return INSTANCE;
		}

		private SootInstructionKindTagger()
		{
		}

		@Override
		public <T> T getTag(BytecodeTagType<T> aType, int aValue)
		{
			if (aType == BytecodeTagType.BYTECODE_ROLE)
			{
				// Constants come from abc.weaving.tagkit.InstructionKindTag
				switch (aValue)
				{
				case 0: return (T) BytecodeRole.BASE_CODE;
				case 1: return (T) BytecodeRole.ADVICE_EXECUTE;
				case 2: return (T) BytecodeRole.ADVICE_ARG_SETUP;
				case 3: return (T) BytecodeRole.ADVICE_TEST;
				case 36: return (T) BytecodeRole.INLINED_ADVICE;
				default: return (T) BytecodeRole.UNKNOWN;
				}
			}
			else return null;
		}
		
	}
	
	/**
	 * Represents a range of bytecodes.
	 * @author gpothier
	 */
	public static class CodeRange
	{
		public final Label start;
		public final Label end;
		
		public CodeRange(Label aStart, Label aEnd)
		{
			start = aStart;
			end = aEnd;
		}
	}
	
	/**
	 * Eases the creation of code ranges.
	 * @author gpothier
	 */
	public static class RangeManager
	{
		private final MethodVisitor mv;
		private final List<CodeRange> itsRanges = new ArrayList<CodeRange>();
		private Label itsCurrentStart;
		
		public RangeManager(MethodVisitor aMv)
		{
			mv = aMv;
		}
		
		public List<CodeRange> getRanges()
		{
			return itsRanges;
		}

		public void start()
		{
			assert itsCurrentStart == null;
			itsCurrentStart = new Label();
			mv.visitLabel(itsCurrentStart);
		}
		
		public void end()
		{
			assert itsCurrentStart != null;
			Label theEnd = new Label();
			mv.visitLabel(theEnd);
			itsRanges.add(new CodeRange(itsCurrentStart, theEnd));
			itsCurrentStart = null;
		}
	}

}
